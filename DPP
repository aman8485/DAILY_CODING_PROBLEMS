1-  Subarray Sums Divisible by K
class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        int [] subs = new int [k];
        subs[0] = 1;
        int ans = 0, psum = 0;
        for (int num : nums) {
            psum += num;
            int x = ((psum % k) + k) % k;
            ans += subs[x];
            subs[x]++;
    }

return ans;
    }
}

2- Count Complete Subarrays in an Array
class Solution {

    public int countCompleteSubarrays(int[] nums) {
        int k = (int) Arrays.stream(nums).distinct().count(), res = 0;
        for (int i = 0; i < nums.length; i++) {
            Set<Integer> st = new HashSet<>();
            for (int j = i; j < nums.length; j++) {
                st.add(nums[j]);
                if (st.size() == k) res++;
            }
        }
        return res;
    }
}

3- Ransom Note

class Solution {
    public boolean canConstruct(String s, String m) {
        int[]check=new int[26];
        for(char ch:m.toCharArray()){
            check[ch-'a']++;
            //check++;
        }
        for(char ch:s.toCharArray()){
            check[ch-'a']--;
            //check--;
            if(check[ch-'a']<0){
                return false;
            }
        }
   return true;
        
    }
}


4- Minimum Operations to Convert All Elements to Zero

class Solution {
    public int minOperations(int[] arr) {
        Stack<Integer> st=new Stack<>();
        int cnt=0;
     for(int n:arr){
        while(!st.isEmpty() && st.peek()>n){
            st.pop();
        }
        if(n==0){
            continue;
        }
        if(st.isEmpty() || st.peek()<n){
            st.push(n);
            cnt++;
        }
     }
     return cnt;
    }
}

5-Convert Sorted List to Binary Search Tree

class Solution {
    public ListNode middle(ListNode head){
        if(head==null) return null;
        ListNode fast=head;
        ListNode slow=head;
        ListNode prev=slow;
        while(fast!=null && fast.next!=null){
             prev=slow;
             slow=slow.next;
            fast=fast.next.next;     
        }
        prev.next=null;
        return slow;
    }
    public TreeNode sortedListToBST(ListNode head) {
        if(head==null) return null;
        if(head.next==null){
            TreeNode node=new TreeNode(head.val);
            return node;
        }
        ListNode mid=middle(head);
        TreeNode root=new TreeNode(mid.val);
        root.left=sortedListToBST(head);
        root.right=sortedListToBST(mid.next);

        return root;

        
    }
}

6- Transform Array by Parity
class Solution {
    public int[] transformArray(int[] arr) {
        int n=arr.length;
        int []brr=new int[n];
        for(int i=0;i<arr.length;i++){
            if(arr[i]%2==0){
                brr[i]=0;
            }else{
                brr[i]=1;
            }
        }
         Arrays.sort(brr);
        return brr;
        
        
    }
}

7-  Check if Any Element Has Prime Frequency
class Solution {
    private  boolean isprime(int n){
        if(n<=1){
            return false;
        }
        for(int i=2;i<=Math.sqrt(n);i++){
            if(n%i==0){
                return false;
            }
        }
        return true;
    }
    public boolean checkPrimeFrequency(int[] arr) {
        HashMap<Integer,Integer> mp=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            mp.put(arr[i],mp.getOrDefault(arr[i],0)+1);
        }  
        for(int i:mp.keySet()){

            int freq=mp.get(i);
            if(isprime(freq)){
                return true;
            }
           
        } 
        return false;     
    }
}

8 -  Count Number of Homogenous Substrings

class Solution {
    public int countHomogenous(String s) {
        int cnt=1;
        int mod=(int)1e9+7;
        int ans=1;
        for(int i=1;i<s.length();i++){
            if(s.charAt(i)==s.charAt(i-1)){
                cnt++;
                
            }else{
                cnt=1;
            }
            ans=(ans+cnt)%mod;
        }
        return ans;
        
    }
}

9-  Shuffle the Array

class Solution {
    public int[] shuffle(int[] arr, int n) {
        int[]ans=new int[2*n];
      for(int i=0;i<n;i++){
        ans[2*i]=arr[i];
        ans[2*i+1]=arr[i+n];
      }
      return ans;
     
}
}
10- Check If All 1's Are at Least Length K Places Away

class Solution {
    public boolean kLengthApart(int[] arr, int k) {
        int pre=-1;

        for(int i=0;i<arr.length;i++){
            if(arr[i]==1){
                if(pre!=-1 && i-pre-1<k){
                    return false;
                }
                pre=i;
            }
        }
    
        return true;
    }
}

11- 1-bit and 2-bit Characters

class Solution {
    public boolean isOneBitCharacter(int[] arr) {
        if(arr.length==1) return true;
        for(int i=0;i<arr.length-1;){
            if(arr[i]==1){
                i+=2;
            }
            else{
                i+=1;
            }
            if(i==arr.length-1) return true;
        }

        return false;
    }
}

12-  Keep Multiplying Found Values by Two
class Solution {
    public int findFinalValue(int[] arr, int original) {
        HashSet<Integer> s =new HashSet<>();
        for(int i=0;i<arr.length;i++){
            s.add(arr[i]);
        }
        for(int i=0;i<s.size();i++){
            if(s.contains(original)){
                original*=2;
            }
        }
 
        return original;
    }
}

13- Largest Number At Least Twice of Others

class Solution {
    public int dominantIndex(int[] arr) {
      int max=-1;
      int maxidx=-1;
      for(int i=0;i<arr.length;i++){
       if(max<arr[i]){
        max=arr[i];
        maxidx=i;
       }
        
      }
      for(int i=0;i<arr.length;i++){
        if(i!=maxidx && (max<2*arr[i])){
            return -1;
        }
      }
     
return maxidx;
    }
}

14- Largest Perimeter Triangle
class Solution {
    public int largestPerimeter(int[] arr) {
        
        Arrays.sort(arr);
        int n=arr.length;
        for(int i=n-1;i>1;i--){
           if(arr[i]<arr[i-1]+arr[i-2]){
            return arr[i]+arr[i-1]+arr[i-2];
           }
        }
        return 0;
    }
}

15- Unique Length-3 Palindromic Subsequences

class Solution {
    public int countPalindromicSubsequence(String s) {
       int ans=0;
       for(char ch='a';ch<='z';ch++){
        int first=s.indexOf(ch);
        int last=s.lastIndexOf(ch);
if(first!=-1 && last!=-1 && last-first>1){
    boolean[]seen=new boolean[26];
    for(int i=first+1;i<last;i++){
        seen[s.charAt(i)-'a']=true;
    }
    int cnt=0;
    for(boolean i:seen){
        if(i){
            cnt++;
        }
    }
    ans+=cnt;
}

       }
       return ans;
        
    }
}
16-  Minimum Moves to Equal Array Elements

class Solution {
    public int minMoves(int[] arr) {
       int min=Integer.MAX_VALUE;
      // int ans=0;
      int n=arr.length;
       for(int i=0;i<arr.length;i++){
        min=Math.min(arr[i],min);
       }
       int sum=0;
       for(int i=0;i<arr.length;i++){
        sum+=arr[i];
       }
       int ans=sum-n*min;
       return ans;
        
    }
}
17- Number of Strings That Appear as Substrings in Word

class Solution {
    public int numOfStrings(String[] arr, String word) {
    int cnt=0;
   
        for(int i=0;i<arr.length;i++){
           if(word.contains(arr[i]))cnt++;
        }
        return cnt;
    }
}

18-  Self Dividing Numbers

class Solution {
    public boolean selfdiv(int num) {
        int n = num;
        while (num > 0) {
            int rem = num % 10;
            if (rem == 0 || n % rem != 0) {
                return false;
            }
            num /= 10;
        }
        return true;
    }
    public List<Integer> selfDividingNumbers(int left, int right) {
        List<Integer> list = new ArrayList<>();
        for (int i = left; i <= right; i++) {
            if (selfdiv(i)) {
                list.add(i);
            }
        }
        return list;
    }
}

19- Average Value of Even Numbers That Are Divisible by Three

class Solution {
    public int averageValue(int[] arr) {
        int cnt=0;
        int sum=0;
       // List<Integer> ans=new ArrayList<>();
        for(int i=0;i<arr.length;i++){
           if(arr[i]%6==0){
            sum+=arr[i];
            cnt++;
           }
        }
        if(cnt==0){
            return 0;
        }else{
            return sum/cnt;
        }
    
        
    }
}

20- Remove Element

class Solution {
    public int removeElement(int[] arr, int val) {
        int cal=0;
        for(int i=0;i<arr.length;i++){
            if(arr[i]!=val){
                int temp=arr[i];
                arr[i]=arr[cal];
                arr[cal]=temp;
                cal++;
            }
        }
  return cal;
    }
}

21- Find the Difference of Two Arrays

class Solution {
    public List<List<Integer>> findDifference(int[] arr, int[] nums) {

        List<List<Integer>> ans=new ArrayList<>();
        HashSet<Integer> s=new HashSet<>();
        HashSet<Integer> p=new HashSet<>();
        for(int i:arr){
            s.add(i);
        }
         for(int i:nums){
            p.add(i);
        }
        List<Integer> a=new ArrayList<>();
       for(int i:s){
        if(!p.contains(i)){
            a.add(i);
        }
       }
       ans.add(a);

           List<Integer> b=new ArrayList<>();
           for(int i:p){
            if(!s.contains(i)){
                b.add(i);
            }
           }
           ans.add(b);
           return ans;


       
        
    }
}

22- Majority Element

class Solution {
    public int majorityElement(int[] arr) {
        int cnt=-1;
        int n=arr.length;
        HashMap<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            map.put(arr[i],map.getOrDefault(arr[i],0)+1);
        }
        for(int ele:arr){
            if(map.get(ele)>n/2){
                cnt=ele;
            }
        }
        return cnt;
    }
}
23- Minimum Operations to Make Array Sum Divisible by K

class Solution {
    public int minOperations(int[] arr, int k) {
        int sum=0;
        int cnt=0;
        for(int i=0;i<arr.length;i++){
            sum+=arr[i];
        }
        cnt=sum%k;
        return cnt;
            
        
    }
}

24- Rearrange Elements by Sign

class Solution {
    public int[] rearrangeArray(int[] arr) {
    int []ans=new int[arr.length];
    int pos=0;
    int neg=1;
    for(int i=0;i<arr.length;i++){
        if(arr[i]>0){
            ans[pos]=arr[i];
            pos+=2;
        }else{
            ans[neg]=arr[i];
            neg+=2;
        }
    }
    return ans;
    }
}

25- Special Array With X Elements Greater Than or Equal X

class Solution {
    public int specialArray(int[] arr) {
      
        for(int i=0;i<=arr.length;i++){
            int cnt=0;
            for(int j:arr){
                if(j>=i)cnt++;
            }
            if(cnt==i)return i;
        }
return -1;
        
    }
}

26- Two Furthest Houses With Different Colors

class Solution {
    public int maxDistance(int[] arr) {
        int cnt=0;
        int max=0;
        for(int i=0;i<arr.length;i++){
            for(int j=i+1;j<arr.length;j++){
                if(arr[i]!=arr[j]){
                    max=Math.abs(i-j);
                    cnt=Math.max(max,cnt);a
                }
            }
        }
        return cnt;
        
    }
}
27- Count Partitions with Even Sum Difference

class Solution {
    public int countPartitions(int[] arr) {
        int total=0;
        int left=0;
        int right=0;
        int cnt=0;
        for(int i=0;i<arr.length;i++){
            total+=arr[i];
        }
        for(int i=0;i<arr.length-1;i++){
            left+=arr[i];
             right=total-left;
             if(Math.abs(left-right)%2==0){
                cnt++;
             }
        }
       
return cnt;
        
    }
}

28- Smallest Range I

class Solution {
    public int smallestRangeI(int[] nums, int k) {
        int min=Integer.MAX_VALUE;
        int max=Integer.MIN_VALUE;
        if(nums.length==1) return 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]<min){
               min=nums[i];
            }
            if(nums[i]>max){
                max=nums[i];
            }
        }
        int ans1=min+k;
        int ans2=max-k;
        int res=ans2-ans1;
     
        if(res<0){
            return 0;
        }
       return res; 
    }
}

29- Baseball Game

class Solution {
    public int calPoints(String[] operations) {
        int[] records = new int[operations.length];
        int pointer = 0;
        
        int sum = 0;

        for (String s : operations) {

            if (s.equals("+")) {
                records[pointer] = records[pointer - 1] + records[pointer - 2];
                pointer++;
            } else if (s.equals("D")) {
                records[pointer] = records[pointer - 1] * 2;
                pointer++;
            } else if (s.equals("C")) {
                records[--pointer] = 0;
            } else {
                records[pointer++] = Integer.parseInt(s);
            }
        }

        for (int rec : records) {
            sum += rec;
        }

        return sum;
    }
}

30-  Count Odd Numbers in an Interval Range

class Solution {
    public int countOdds(int low, int high) {
       return (high+1)/2-low/2;
        
    }
}

31-Count Square Sum Triples

class Solution {
    public int countTriples(int n) {
        int cnt=0;
        for(int a=1;a<=n;a++){
            for(int b=1;b<=n;b++){
                int square=a*a+b*b;
                 int c=(int) Math.sqrt(square);
            if(c<=n && c*c==square){
                cnt++;
            }
            }
           
        }
        return cnt;
        
    }
}
32- Delete Columns to Make Sorted II

class Solution {
    public int minDeletionSize(String[] s) {
        int r = s.length, c = s[0].length();
        int count = 0;

        boolean[] already_sorted = new boolean[r];

        for (int col = 0; col < c; col++) {
            boolean need_to_delete = false;

            for (int row = 1; row < r; row++) {
                if (!already_sorted[row - 1]) {
                    if (s[row].charAt(col) < s[row - 1].charAt(col)) {
                        need_to_delete = true;
                        break;
                    }
                }
            }

            if (need_to_delete) {
                count++;
            } else {
                for (int row = 1; row < r; row++) {
                    if (!already_sorted[row - 1]) {
                        if (s[row].charAt(col) > s[row - 1].charAt(col)) {
                            already_sorted[row - 1] = true;  
                        }
                    }
                }
            }
        }

        return count;
    }
}

33-  Minimum Penalty for a Shop

class Solution {
    public int bestClosingTime(String customers) {
        int penalty = 0, best_penalty = 0, ans = 0;
        char[] ch = customers.toCharArray();
        for(int i = 0; i < customers.length(); i++) {
            if(ch[i] == 'Y') {
                penalty--;
                if(penalty < best_penalty) {
                    best_penalty = penalty;
                    ans = i + 1;
                }
            }
            else penalty++;
        }
        return ans;
    }
}

34- Longest Consecutive Sequence



class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) return 0;
        
        HashSet<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }

        int longest = 0;

        for (int num : set) {
            if (!set.contains(num - 1)) {
                int current = num;
                int streak = 1;

                while (set.contains(current + 1)) {
                    current++;
                    streak++;
                }

                longest = Math.max(longest, streak);
            }
        }

        return longest;
    }
}

35- Count Negative Numbers in a Sorted Matrix

class Solution {
    public int countNegatives(int[][] arr) {
        int cnt=0;
   for(int []i:arr){
    Arrays.sort(i);
    for(int v:i){
        if(v<0) cnt++;
        else break;
    }
   }
      return cnt;  
    }
}

36- Count Pairs That Form a Complete Day I

class Solution {
    public int countCompleteDayPairs(int[] arr) {
        int cnt=0;
        for(int i=0;i<arr.length;i++){
            for(int j=i+1;j<arr.length;j++){
                if((arr[i]+arr[j])%24==0){
                    cnt++;
                }
            }
        }
        return cnt;
        
    }
}

37- Minimum Time Visiting All Points

class Solution {
    public int minTimeToVisitAllPoints(int[][] p) {
        int ans = 0;
        for (int i = 1; i < p.length; i++) {
            ans += Math.max(
                Math.abs(p[i][0] - p[i - 1][0]),
                Math.abs(p[i][1] - p[i - 1][1])
            );
        }
        return ans;
    }
}

38-  Find the Smallest Divisor Given a Threshold

class Solution {
     private int sumbyd(int[]arr,int limit){
        int sum=0;
        for(int i=0;i<arr.length;i++){
            sum+=Math.ceil((double)arr[i]/(double)(limit));
        }
        return sum;

    }
    public int smallestDivisor(int[] arr, int limit) {

           if(arr.length>limit) return -1;
        int maxi=Integer.MIN_VALUE;
    for(int i=0;i<arr.length;i++){
        maxi=Math.max(arr[i],maxi);
    }
    int low=1;
    int high=maxi;
    int ans=-1;
    while(low<=high){
        int mid=high+(low-high)/2;
        if(sumbyd(arr,mid)<=limit){
            ans=mid;
            high=mid-1;
        }else{
            low=mid+1;
        }
    }
    return ans;

        
    }
}

39- Minimum Number of Days to Make m Bouquets

class Solution {
     private boolean possibledays(int[]arr,int days,int m,int k){
        int cnt=0;
        int noofboookay=0;
        for(int i=0;i<arr.length;i++){
            if(arr[i]<=days){
                cnt++;
            }else{
                noofboookay+=(cnt/k);
                cnt=0;

            }

        }
        noofboookay+=(cnt/k);
        return noofboookay>=m;
    }
    public int minDays(int[] arr, int m, int k) {

         long val=(long)m*k;
        if(val>arr.length) return -1;

             int mini = Integer.MAX_VALUE, maxi = Integer.MIN_VALUE;
        for (int i = 0; i < arr.length; i++) {
            mini = Math.min(mini, arr[i]); 
            maxi = Math.max(maxi, arr[i]); 
        }

        int low=mini;
        int high=maxi;
        int ans=-1;
        while(low<=high){
            int mid=high+(low-high)/2;
            if(possibledays(arr,mid,m,k)){
                ans=mid;
                high=mid-1;
            }else{
                low=mid+1;
            }
        }

        return ans;
        
    }
}

40- Pow(X,N)

class Solution {
    private double power(double x,double n){
        if(n==0)return 1.0;
        if(n==1) return x;
        if(n%2==0){
            return power(x*x,n/2);
        }else{
            return x*power(x,n-1);
        }
    }
    public double myPow(double x, int n) {
          //your code goes here
          long num=n;
          if(num<0){
            return (1.0/power(x,-num));
          }
          return power(x,num);

    }
}

41-

50- Construct the Minimum Bitwise Array I
class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            if (num == 2) {
                ans[i] = -1;
            } else {
                int k = Integer.numberOfTrailingZeros(num + 1);
                ans[i] = num - (1 << (k - 1));
            }
        }
        return ans;
    }
}

51- Lemonade Change

class Solution {
    public boolean lemonadeChange(int[] arr) {
        int five=0;
        int ten=0;
        for(int i=0;i<arr.length;i++){
            if(arr[i]==5) five++;
            else if(arr[i]==10){
                if(five>0){
                    five--;
                    ten++;
                }else{
                    return false;
                }
            }else{
                if(five>0 && ten>0){
                    five--;
                    ten--;
                }
                else if(five>=3){
                    five-=3;
                }else{
                    return false;
                }
            }
        }
        return true;
    }
}

52-Minimize Maximum Pair Sum in Array

class Solution {
    public int minPairSum(int[] arr) {
        Arrays.sort(arr);
        int i=0;
        int j=arr.length-1;
        int maxsm=0;
        while(i<j){
            int pairsum=arr[i]+arr[j];
            if(pairsum>maxsm){
                maxsm=pairsum;
            }
            i++;
            j--;
        }
        return maxsm;
    }
}

53-Jump Game

class Solution {
    public boolean canJump(int[] arr) {
        int maxidx=0;
        for(int i=0;i<arr.length;i++){
            if(i>maxidx) return false;
            maxidx=Math.max(maxidx,arr[i]+i);
        }
        return true;
        
    }
}
54-  Maximum Points You Can Obtain from Cards

class Solution {
    public int maxScore(int[] arr, int k) {
        int lsum=0;
        int maxsum=0;
        for(int i=0;i<k;i++){
            lsum+=arr[i];
            maxsum=lsum;
        }
        int rightidx=arr.length-1;
        int rightsum=0;
        for(int i=k-1;i>=0;i--){
            lsum-=arr[i];
            rightsum+=arr[rightidx];
            rightidx--;
            maxsum=Math.max(maxsum,lsum+rightsum); 
        }
        return maxsum;
        
    }
}

55-Find Smallest Letter Greater Than Target

class Solution {
    public char nextGreatestLetter(char[] arr, char target) {
        for(int i=0;i<arr.length;i++){
            if(arr[i]>target){
                return arr[i];
            }
        }
        return arr[0];
    }
}

56- Divide an Array Into Subarrays With Minimum Cost I

class Solution {
    public int minimumCost(int[] arr) {
       Arrays.sort(arr,1,arr.length);
       return arr[0]+arr[1]+arr[2];
    }
}

57-Min Cost Climbing Stairs

class Solution {
    private int mincost(int[]arr,int idx,int[] dp){
        if(idx==0 || idx==1) return arr[idx];
        if(dp[idx]!=-1) return dp[idx];
        return dp[idx]=arr[idx]+Math.min(mincost(arr,idx-1,dp),mincost(arr,idx-2,dp));
    }
    public int minCostClimbingStairs(int[] arr) {
        int n=arr.length;
        int[]dp=new int[n];
        Arrays.fill(dp,-1);
        return Math.min(mincost(arr,n-1,dp),mincost(arr,n-2,dp));
        
    }
}
