1-  Subarray Sums Divisible by K

class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        int [] subs = new int [k];
        subs[0] = 1;
        int ans = 0, psum = 0;

        for (int num : nums) {
            psum += num;
            int x = ((psum % k) + k) % k;
            ans += subs[x];
            subs[x]++;
        }
        return ans;
    }
}
2- Count Complete Subarrays in an Array
class Solution {
    public int countCompleteSubarrays(int[] nums) {
        int k = (int) Arrays.stream(nums).distinct().count(), res = 0;
        for (int i = 0; i < nums.length; i++) {
            Set<Integer> st = new HashSet<>();
            for (int j = i; j < nums.length; j++) {
                st.add(nums[j]);
                if (st.size() == k) res++;
            }
        }
        return res;
    }
}

3- Ransom Note

class Solution {
    public boolean canConstruct(String s, String m) {
        int[]check=new int[26];
        for(char ch:m.toCharArray()){
            check[ch-'a']++;
            //check++;
        }
        for(char ch:s.toCharArray()){
            check[ch-'a']--;
            //check--;
            if(check[ch-'a']<0){
                return false;
            }
        }
   return true;
        
    }
}


4- Minimum Operations to Convert All Elements to Zero

class Solution {
    public int minOperations(int[] arr) {
        Stack<Integer> st=new Stack<>();
        int cnt=0;
     for(int n:arr){
        while(!st.isEmpty() && st.peek()>n){
            st.pop();
        }
        if(n==0){
            continue;
        }
        if(st.isEmpty() || st.peek()<n){
            st.push(n);
            cnt++;
        }
     }
     return cnt;
    }
}

5-Convert Sorted List to Binary Search Tree

class Solution {
    public ListNode middle(ListNode head){
        if(head==null) return null;
        ListNode fast=head;
        ListNode slow=head;
        ListNode prev=slow;
        while(fast!=null && fast.next!=null){
             prev=slow;
             slow=slow.next;
            fast=fast.next.next;     
        }
        prev.next=null;
        return slow;
    }
    public TreeNode sortedListToBST(ListNode head) {
        if(head==null) return null;
        if(head.next==null){
            TreeNode node=new TreeNode(head.val);
            return node;
        }
        ListNode mid=middle(head);
        TreeNode root=new TreeNode(mid.val);
        root.left=sortedListToBST(head);
        root.right=sortedListToBST(mid.next);

        return root;

        
    }
}

6- Transform Array by Parity
class Solution {
    public int[] transformArray(int[] arr) {
        int n=arr.length;
        int []brr=new int[n];
        for(int i=0;i<arr.length;i++){
            if(arr[i]%2==0){
                brr[i]=0;
            }else{
                brr[i]=1;
            }
        }
         Arrays.sort(brr);
        return brr;
        
        
    }
}

7-  Check if Any Element Has Prime Frequency
class Solution {
    private  boolean isprime(int n){
        if(n<=1){
            return false;
        }
        for(int i=2;i<=Math.sqrt(n);i++){
            if(n%i==0){
                return false;
            }
        }
        return true;
    }
    public boolean checkPrimeFrequency(int[] arr) {
        HashMap<Integer,Integer> mp=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            mp.put(arr[i],mp.getOrDefault(arr[i],0)+1);
        }  
        for(int i:mp.keySet()){

            int freq=mp.get(i);
            if(isprime(freq)){
                return true;
            }
           
        } 
        return false;     
    }
}

8 -  Count Number of Homogenous Substrings

class Solution {
    public int countHomogenous(String s) {
        int cnt=1;
        int mod=(int)1e9+7;
        int ans=1;
        for(int i=1;i<s.length();i++){
            if(s.charAt(i)==s.charAt(i-1)){
                cnt++;
                
            }else{
                cnt=1;
            }
            ans=(ans+cnt)%mod;
        }
        return ans;
        
    }
}

9-  Shuffle the Array

class Solution {
    public int[] shuffle(int[] arr, int n) {
        int[]ans=new int[2*n];
      for(int i=0;i<n;i++){
        ans[2*i]=arr[i];
        ans[2*i+1]=arr[i+n];
      }
      return ans;
     
}
}
10- Check If All 1's Are at Least Length K Places Away

class Solution {
    public boolean kLengthApart(int[] arr, int k) {
        int pre=-1;

        for(int i=0;i<arr.length;i++){
            if(arr[i]==1){
                if(pre!=-1 && i-pre-1<k){
                    return false;
                }
                pre=i;
            }
        }
    
        return true;
    }
}

11- 1-bit and 2-bit Characters

class Solution {
    public boolean isOneBitCharacter(int[] arr) {
        if(arr.length==1) return true;
        for(int i=0;i<arr.length-1;){
            if(arr[i]==1){
                i+=2;
            }
            else{
                i+=1;
            }
            if(i==arr.length-1) return true;
        }

        return false;
    }
}
